<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Clone do Snake.io</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #33ff33;
            --background-color: #121212;
            --container-bg: #1a1a1a;
            --border-color: #4a4a4a;
        }
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: var(--background-color);
            color: #ffffff;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        .game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 10px;
        }
        .game-container {
            border: 4px solid var(--border-color);
            border-radius: 10px;
            box-shadow: 0 0 25px rgba(0, 255, 127, 0.5);
            background-color: var(--container-bg);
            padding: 10px;
            width: 100%;
            max-width: 640px;
            display: flex;
            flex-direction: column;
        }
        canvas#gameCanvas {
            background-color: #000000;
            border: 2px solid var(--primary-color);
            border-radius: 5px;
            width: 100%;
            height: auto;
            aspect-ratio: 1 / 1;
        }
        .ui-panel {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
            font-size: 0.8rem;
        }
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid var(--primary-color);
            text-align: center;
            z-index: 200;
            width: 80%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        #leaderboard {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--border-color);
            border-radius: 5px;
            padding: 10px;
            font-size: 0.7rem;
            width: 180px;
            color: #ccc;
        }
        #leaderboard h3 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
            text-align: center;
        }
        #leaderboard ol {
            margin: 0;
            padding: 0;
            list-style-type: none;
        }
        #leaderboard li {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        #leaderboard li span:first-child {
            font-weight: bold;
            color: #fff;
        }
        #mobile-controls {
            width: 100%;
            margin-top: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #mobile-controls button {
            background-color: rgba(55, 65, 81, 0.7);
            border: 2px solid var(--border-color);
            color: white;
            font-size: 2rem;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            user-select: none;
            -webkit-user-select: none;
        }
        #boost-btn {
            font-size: 1.5rem;
            width: 90px;
            height: 90px;
        }
    </style>
</head>
<body>

<div class="game-wrapper">
    <div class="game-container">
        <h1 class="text-xl md:text-3xl text-center mb-2 text-[#33ff33]">SNAKE BATTLE</h1>
        <canvas id="gameCanvas"></canvas>
        <div class="ui-panel">
            <div>PONTOS: <span id="score">0</span></div>
            <div>VIVOS: <span id="snakes-alive">1</span></div>
        </div>
        <div class="controls text-xs text-center mt-2 text-gray-400 hidden md:block">
            Use as SETAS ◀ e ▶ para virar | ESPAÇO para acelerar
        </div>
        <div id="mobile-controls" class="md:hidden">
            <button id="left-btn">◀</button>
            <button id="boost-btn">⚡</button>
            <button id="right-btn">▶</button>
        </div>
    </div>
</div>

<div id="leaderboard" class="hidden md:block">
    <h3>Classificação</h3>
    <ol id="leaderboard-list"></ol>
</div>

<div id="gameOverMessage" class="message-box" style="display: none;">
    <h2 class="message-box-title">Fim de Jogo!</h2>
    <p id="finalScore" class="message-box-score"></p>
    <button id="restartButton">Jogar Novamente</button>
</div>


<script>
    // --- Configurações do Jogo ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const leaderboardList = document.getElementById('leaderboard-list');
    const scoreElement = document.getElementById('score');
    const snakesAliveElement = document.getElementById('snakes-alive');
    const gameOverMessage = document.getElementById('gameOverMessage');
    const finalScoreElement = document.getElementById('finalScore');
    const restartButton = document.getElementById('restartButton');
    const leftBtn = document.getElementById('left-btn');
    const rightBtn = document.getElementById('right-btn');
    const boostBtn = document.getElementById('boost-btn');

    const NUM_BOTS = 15;
    const NUM_PELLETS = 250;
    const WORLD_WIDTH = 2500;
    const WORLD_HEIGHT = 2500;

    // --- Estado do Jogo ---
    let player, bots, pellets;
    let gameInterval, isGameOver;
    let camera = { x: 0, y: 0 };
    let keys = { ArrowLeft: false, ArrowRight: false, Space: false };
    
    const BOT_NAMES = ["Ghost", "Viper", "Raptor", "Siren", "Jaws", "Spike", "Shadow", "Blaze", "Fury", "Titan", "Reaper", "Worm", "Doom", "Cobra", "Venom"];

    // --- Funções Principais ---
    function createSnake(x, y, color, name) {
        return {
            name: name,
            body: [{ x, y }],
            angle: Math.random() * 2 * Math.PI,
            speed: 1.8,
            turnSpeed: 0.05,
            radius: 7,
            color: color,
            score: 0,
            isBoosting: false,
            targetPellet: null,
            attractionRadius: 60, 
            attractionSpeed: 0.3,
            // NOVIDADE: Propriedades da IA
            state: 'HUNTING', // Estados: 'HUNTING' ou 'ATTACKING'
            targetSnake: null,
            aggroRadius: 250 // Raio para se tornar agressivo
        };
    }

    function startGame() {
        resizeCanvas();
        player = createSnake(WORLD_WIDTH / 2, WORLD_HEIGHT / 2, '#00ff00', 'Você');
        bots = [];
        const usedNames = [...BOT_NAMES];
        for (let i = 0; i < NUM_BOTS; i++) {
            const nameIndex = Math.floor(Math.random() * usedNames.length);
            const botName = usedNames.splice(nameIndex, 1)[0];
            bots.push(createSnake(
                Math.random() * WORLD_WIDTH,
                Math.random() * WORLD_HEIGHT,
                `hsl(${Math.random() * 360}, 100%, 75%)`,
                botName
            ));
        }
        pellets = [];
        for (let i = 0; i < NUM_PELLETS; i++) {
            spawnPellet();
        }
        isGameOver = false;
        keys = { ArrowLeft: false, ArrowRight: false, Space: false };
        updateUI();
        gameOverMessage.style.display = 'none';
        if (gameInterval) clearInterval(gameInterval);
        gameInterval = setInterval(gameLoop, 1000 / 60);
    }
    
    function resizeCanvas() {
        const size = canvas.clientWidth;
        canvas.width = size;
        canvas.height = size;
    }

    function gameLoop() {
        if (isGameOver) return;
        handleInput();
        updatePlayer();
        updateBots(); // IA foi atualizada aqui
        updatePellets();
        updateCamera();
        checkCollisions();
        drawGame();
        updateLeaderboard();
        updateUI();
    }

    // --- Desenho ---
    function drawGame() {
        ctx.fillStyle = '#000000';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(-camera.x, -camera.y);
        drawWorldBackground();
        pellets.forEach(p => drawCircle(p.x, p.y, p.radius, p.color));
        if (player) drawSnake(player);
        bots.forEach(drawSnake);
        ctx.restore();
    }

    function drawSnake(snake) {
        for (let i = 0; i < snake.body.length; i++) {
            const segment = snake.body[i];
            const radius = snake.radius * (1 - i / (snake.body.length * 1.5));
            drawCircle(segment.x, segment.y, Math.max(2, radius), snake.color);
        }
    }
    
    function drawCircle(x, y, radius, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fill();
    }

    function drawWorldBackground() {
        ctx.strokeStyle = '#33ff33';
        ctx.lineWidth = 10;
        ctx.strokeRect(0, 0, WORLD_WIDTH, WORLD_HEIGHT);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
        ctx.lineWidth = 1;
        const gridSize = 50;
        for (let x = 0; x <= WORLD_WIDTH; x += gridSize) {
            ctx.beginPath();
            ctx.moveTo(x, 0);
            ctx.lineTo(x, WORLD_HEIGHT);
            ctx.stroke();
        }
        for (let y = 0; y <= WORLD_HEIGHT; y += gridSize) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(WORLD_WIDTH, y);
            ctx.stroke();
        }
    }

    // --- Lógica de Atualização ---
    function handleInput() {
        if (!player) return;
        if (keys.ArrowLeft) player.angle -= player.turnSpeed;
        if (keys.ArrowRight) player.angle += player.turnSpeed;
        player.isBoosting = keys.Space;
    }

    function updatePlayer() {
        if (!player) return;
        moveSnake(player);
    }

    // NOVIDADE: IA Agressiva
    function updateBots() {
        const allSnakes = [player, ...bots].filter(s => s);

        bots.forEach(bot => {
            // Lógica de decisão do estado
            let potentialTarget = null;
            let closestDist = bot.aggroRadius;

            allSnakes.forEach(otherSnake => {
                if (bot === otherSnake || !otherSnake) return;
                const dist = Math.hypot(bot.body[0].x - otherSnake.body[0].x, bot.body[0].y - otherSnake.body[0].y);
                
                // Se o outro for menor, estiver perto e mais perto que o alvo anterior
                if (dist < closestDist && bot.score > otherSnake.score + 10) { // Precisa de uma vantagem de pontos para atacar
                    closestDist = dist;
                    potentialTarget = otherSnake;
                }
            });

            // Se encontrou um alvo, muda para o estado de ataque
            if (potentialTarget) {
                bot.state = 'ATTACKING';
                bot.targetSnake = potentialTarget;
            } 
            // Se estava a atacar mas o alvo fugiu, morreu ou ficou maior, volta a caçar
            else if (bot.state === 'ATTACKING') {
                bot.state = 'HUNTING';
                bot.targetSnake = null;
                bot.isBoosting = false;
            }

            // Executa a ação com base no estado
            if (bot.state === 'ATTACKING' && bot.targetSnake) {
                // Lógica de ataque: interceptar o alvo
                const targetHead = bot.targetSnake.body[0];
                const predictionDistance = 50 + bot.targetSnake.score / 2;
                const interceptionPoint = {
                    x: targetHead.x + Math.cos(bot.targetSnake.angle) * predictionDistance,
                    y: targetHead.y + Math.sin(bot.targetSnake.angle) * predictionDistance
                };

                const targetAngle = Math.atan2(interceptionPoint.y - bot.body[0].y, interceptionPoint.x - bot.body[0].x);
                bot.angle += Math.sign(targetAngle - bot.angle) * bot.turnSpeed * 1.5; // Vira mais rápido ao atacar
                bot.isBoosting = true;
            } else {
                // Lógica de caça (HUNTING)
                bot.isBoosting = false;
                if (!bot.targetPellet || Math.random() < 0.005) {
                    bot.targetPellet = findClosestPellet(bot);
                }
                if (bot.targetPellet) {
                    const targetAngle = Math.atan2(bot.targetPellet.y - bot.body[0].y, bot.targetPellet.x - bot.body[0].x);
                    bot.angle += Math.sign(targetAngle - bot.angle) * bot.turnSpeed * 0.5;
                }
            }
            
            moveSnake(bot);
        });
    }
    
    function moveSnake(snake) {
        const currentSpeed = snake.isBoosting ? snake.speed * 2 : snake.speed;
        const head = snake.body[0];
        const newHead = {
            x: head.x + Math.cos(snake.angle) * currentSpeed,
            y: head.y + Math.sin(snake.angle) * currentSpeed
        };
        snake.body.unshift(newHead);
        
        const snakeLength = 15 + snake.score;
        while (snake.body.length > snakeLength && snake.body.length > 2) {
            snake.body.pop();
        }
    }

    function updatePellets() {
        const allSnakes = [player, ...bots].filter(s => s);
        pellets.forEach(p => {
            p.vx *= 0.95;
            p.vy *= 0.95;
            allSnakes.forEach(snake => {
                if (!snake) return;
                const head = snake.body[0];
                const distance = Math.hypot(p.x - head.x, p.y - head.y);
                if (distance < snake.attractionRadius) {
                    const dx = head.x - p.x;
                    const dy = head.y - p.y;
                    p.vx += (dx / distance) * snake.attractionSpeed;
                    p.vy += (dy / distance) * snake.attractionSpeed;
                }
            });
            p.x += p.vx;
            p.y += p.vy;
        });
    }

    function updateCamera() {
        if (!player) return;
        camera.x = player.body[0].x - canvas.width / 2;
        camera.y = player.body[0].y - canvas.height / 2;
        camera.x = Math.max(0, Math.min(camera.x, WORLD_WIDTH - canvas.width));
        camera.y = Math.max(0, Math.min(camera.y, WORLD_HEIGHT - canvas.height));
    }

    // --- Colisões, Morte e Fim de Jogo ---
    function checkCollisions() {
        const allSnakes = [player, ...bots].filter(s => s);
        for (let i = allSnakes.length - 1; i >= 0; i--) {
            const currentSnake = allSnakes[i];
            if (!currentSnake) continue;
            const head = currentSnake.body[0];

            if (head.x < currentSnake.radius || head.x > WORLD_WIDTH - currentSnake.radius || head.y < currentSnake.radius || head.y > WORLD_HEIGHT - currentSnake.radius) {
                killSnake(currentSnake);
                continue;
            }

            for (let j = pellets.length - 1; j >= 0; j--) {
                const p = pellets[j];
                if (Math.hypot(head.x - p.x, head.y - p.y) < currentSnake.radius + p.radius) {
                    currentSnake.score += p.value;
                    pellets.splice(j, 1);
                    spawnPellet();
                }
            }

            for (let j = 0; j < allSnakes.length; j++) {
                const otherSnake = allSnakes[j];
                if (!otherSnake) continue;

                for (let k = 0; k < otherSnake.body.length; k++) {
                    if (currentSnake === otherSnake && k < 4) {
                        continue; 
                    }
                    const segment = otherSnake.body[k];
                    if (Math.hypot(head.x - segment.x, head.y - segment.y) < currentSnake.radius) {
                        killSnake(currentSnake);
                        j = allSnakes.length; 
                        break;
                    }
                }
            }
        }
    }

    function killSnake(snake) {
        snake.body.forEach((segment, i) => {
            if (i % 5 === 0) {
                spawnPellet(segment.x, segment.y, 5, "#ffffff");
            }
        });

        if (snake === player) {
            endGame(player ? player.score : 0);
            player = null;
        } else {
            const botIndex = bots.indexOf(snake);
            if (botIndex > -1) {
                bots.splice(botIndex, 1);
            }
        }
    }

    function endGame(score) {
        isGameOver = true;
        clearInterval(gameInterval);
        finalScoreElement.textContent = `Pontuação Final: ${score}`;
        gameOverMessage.style.display = "flex";
    }
    
    // --- Funções de UI ---
    function updateLeaderboard() {
        const allSnakes = [player, ...bots].filter(s => s);
        allSnakes.sort((a, b) => b.score - a.score);
        leaderboardList.innerHTML = '';
        const top5 = allSnakes.slice(0, 5);
        top5.forEach(snake => {
            const li = document.createElement('li');
            const nameSpan = document.createElement('span');
            nameSpan.textContent = snake.name;
            if (snake === player) {
                nameSpan.style.color = player.color;
            }
            const scoreSpan = document.createElement('span');
            scoreSpan.textContent = snake.score;
            li.appendChild(nameSpan);
            li.appendChild(scoreSpan);
            leaderboardList.appendChild(li);
        });
    }

    function updateUI() {
        scoreElement.textContent = player ? player.score : 0;
        snakesAliveElement.textContent = bots.length + (player ? 1 : 0);
    }

    // --- Controles e Inicialização ---
    function spawnPellet(x, y, value = 1, color) {
        pellets.push({
            x: x || Math.random() * WORLD_WIDTH,
            y: y || Math.random() * WORLD_HEIGHT,
            radius: value > 1 ? 4 : 2,
            value: value,
            color: color || `hsl(${Math.random() * 360}, 100%, 50%)`,
            vx: 0,
            vy: 0
        });
    }

    function findClosestPellet(t){let o=null,e=1/0;return pellets.forEach(a=>{const s=Math.hypot(t.body[0].x-a.x,t.body[0].y-a.y);s<e&&(e=s,o=a)}),o}
    
    window.addEventListener('resize', resizeCanvas);
    document.addEventListener('keydown', e => { if (e.code in keys) keys[e.code] = true; });
    document.addEventListener('keyup', e => { if (e.code in keys) keys[e.code] = false; });
    restartButton.addEventListener('click', startGame);
    leftBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.ArrowLeft = true; });
    leftBtn.addEventListener('touchend', e => { e.preventDefault(); keys.ArrowLeft = false; });
    rightBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.ArrowRight = true; });
    rightBtn.addEventListener('touchend', e => { e.preventDefault(); keys.ArrowRight = false; });
    boostBtn.addEventListener('touchstart', e => { e.preventDefault(); keys.Space = true; });
    boostBtn.addEventListener('touchend', e => { e.preventDefault(); keys.Space = false; });

    startGame();
</script>

</body>
</html>
